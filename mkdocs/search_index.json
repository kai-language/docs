{
    "docs": [
        {
            "location": "/install/", 
            "text": "", 
            "title": "Install"
        }, 
        {
            "location": "/", 
            "text": "The Basics\n\n\nKai is a new programming language that aims to be C with a touch of modernism. Kai is about the freedom and speed. Write code how you want, we'll stay out of your way. If you're new here, \nInstall Kai\n to get started!\n\n\nGetting Started\n\n\nAs per tradition, let's start with a hello world application.\n\n\n1\nprint\n(\nHello, world!\n)\n\n\n\n\n\n\n\n\n\nWarning\n\n\nStatements in global scope are temporarily disabled. As global scope is limited to declarations, please define a \nmain\n procedure.\n\n\n\n\nUnlike many other programming languages, Kai doesn't require you to explicitly define a \nmain()\n or import any \nmodules\n to build an application.\n\n\nVariables and Constants\n\n\nVariables and constants match a name to a value (similar to \nx\n in algebra). Variables are values that are allowed to change (\nmutable\n/\nruntime\n) while constants are values that aren't allowed to change (\nimmutable\n/\ncompile-time\n).\n\n\nSimple Declarations\n\n\nThe syntax for declaring a variable is quite straightforward. Simply provide a name followed by \n:=\n and a value.\n\n\nHere's an example:\n\n\n1\nx\n \n:=\n \n15\n\n\n\n\n\n\n\nThe previous line created a variable named \nx\n and set its value to \n15\n.\n\n\nIt's also possible to declare a variable using another variable (or constant) as its value. The following example will create a variable \na\n with the value \n1\n and another variable \nb\n with the value of \na\n (also \n1\n).\n\n\n1\n2\na\n \n:=\n \n1\n\n\nb\n \n:=\n \na\n\n\n\n\n\n\n\nYou can combine the previous example into a single line.\n\n\n1\na\n,\n \nb\n \n:=\n \n1\n,\n \n1\n\n\n\n\n\n\n\nAs a variable is a mutable value, you can change its value by using the \nassignment operator\n (\n=\n)\n\n\n1\n2\nx\n \n:=\n \n0\n\n\nx\n \n=\n \n7\n\n\n\n\n\n\n\nx\n will now have the value \n7\n. Try printing it:\n\n\n1\nprint\n(\nx\n)\n\n\n\n\n\n\n\nIf you want to declare a value as a constant, you can use the \nconstant declaration operator\n (\n::\n).\n\n\n1\nseven\n \n::\n \n7\n\n\n\n\n\n\n\nSince a constant is immutable, the following code will cause an error:\n\n\n1\n2\nseven\n \n::\n \n7\n\n\nseven\n \n=\n \n2\n \n// error\n\n\n\n\n\n\n\nType Annotation\n\n\nIn most cases, the compiler is smart enough to infer the type of variable you want to use, but in certain cercumstances you may be required to give it a hint/annotation. Doing so is quite similar to a normal variable declaration.\n\n\nFirst, let's start with annotating a variable value:\n\n\n1\nage\n \n:\n \ni64\n \n=\n \n23\n\n\n\n\n\n\n\nNow, a constant value:\n\n\n1\nfive\n \n:\n \ni64\n \n:\n \n5\n\n\n\n\n\n\n\n\n\nNote\n\n\nLearn more about \nKai Types\n \nhere\n\n and \nCompile Time Execution\n \nhere\n.\n\n\n\n\nNaming\n\n\nVariables and constants can be named just about any unicode character other than whitespace and mathematical symbols. When a value is named, that name cannot be used again within the same \nscope\n. Names (\nidentifiers\n) cannot start with a number, but a number can be included within the name.\n\n\n1\n2\n3\n\uc774\ub984\n \n:=\n \n\ub9cc\uc138\n\n\n\ud83d\udd12\n  \n:=\n \ntrue\n\n\n\u03c4\n   \n:=\n \n6.28\n\n\n\n\n\n\n\nScope and Shadowing\n\n\nBlocks of code are organised as scopes. A scope is defined as the code in-between \n{\n and \n}\n. You are entering a scope when you see \n{\n and exiting when you see \n}\n. Variables and constants are allowed to enter a scope, but they are not allowed to leave the scope they are declared in.\n\n\nFor example:\n\n\n1\n2\n3\n4\n5\nmessage\n \n:=\n \nHello!\n\n\n\n{\n\n    \nprint\n(\nmessage\n)\n \n// Prints \nHello!\n\n\n}\n\n\n\n\n\n\n\nis allowed because \nmessage\n is going deeper in scope. But:\n\n\n1\n2\n3\n4\n5\n{\n\n    \nmessage\n \n:=\n \nHello!\n\n\n}\n\n\n\nprint\n(\nmessage\n)\n \n// Error \nUnknown identifier `message`\n\n\n\n\n\n\n\nis not allowed because \nmessage\n is not allowed to exit the scope it was declared in. When entering a new scope, you are allowed to reuse names. This feature is known as \nshadowing\n.\n\n\n1\n2\n3\n4\n5\n6\n7\naValue\n \n:=\n \n8675309\n\n\n{\n\n    \naValue\n \n:=\n \nI shadowed a value.\n\n    \nprint\n(\naValue\n)\n \n// Prints \nI shadowed a value.\n\n\n}\n\n\n\nprint\n(\naValue\n)\n \n// Prints \n8675309", 
            "title": "The Basics"
        }, 
        {
            "location": "/#the-basics", 
            "text": "Kai is a new programming language that aims to be C with a touch of modernism. Kai is about the freedom and speed. Write code how you want, we'll stay out of your way. If you're new here,  Install Kai  to get started!", 
            "title": "The Basics"
        }, 
        {
            "location": "/#getting-started", 
            "text": "As per tradition, let's start with a hello world application.  1 print ( Hello, world! )     Warning  Statements in global scope are temporarily disabled. As global scope is limited to declarations, please define a  main  procedure.   Unlike many other programming languages, Kai doesn't require you to explicitly define a  main()  or import any  modules  to build an application.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#variables-and-constants", 
            "text": "Variables and constants match a name to a value (similar to  x  in algebra). Variables are values that are allowed to change ( mutable / runtime ) while constants are values that aren't allowed to change ( immutable / compile-time ).", 
            "title": "Variables and Constants"
        }, 
        {
            "location": "/#simple-declarations", 
            "text": "The syntax for declaring a variable is quite straightforward. Simply provide a name followed by  :=  and a value.  Here's an example:  1 x   :=   15    The previous line created a variable named  x  and set its value to  15 .  It's also possible to declare a variable using another variable (or constant) as its value. The following example will create a variable  a  with the value  1  and another variable  b  with the value of  a  (also  1 ).  1\n2 a   :=   1  b   :=   a    You can combine the previous example into a single line.  1 a ,   b   :=   1 ,   1    As a variable is a mutable value, you can change its value by using the  assignment operator  ( = )  1\n2 x   :=   0  x   =   7    x  will now have the value  7 . Try printing it:  1 print ( x )    If you want to declare a value as a constant, you can use the  constant declaration operator  ( :: ).  1 seven   ::   7    Since a constant is immutable, the following code will cause an error:  1\n2 seven   ::   7  seven   =   2   // error", 
            "title": "Simple Declarations"
        }, 
        {
            "location": "/#type-annotation", 
            "text": "In most cases, the compiler is smart enough to infer the type of variable you want to use, but in certain cercumstances you may be required to give it a hint/annotation. Doing so is quite similar to a normal variable declaration.  First, let's start with annotating a variable value:  1 age   :   i64   =   23    Now, a constant value:  1 five   :   i64   :   5     Note  Learn more about  Kai Types   here \n and  Compile Time Execution   here .", 
            "title": "Type Annotation"
        }, 
        {
            "location": "/#naming", 
            "text": "Variables and constants can be named just about any unicode character other than whitespace and mathematical symbols. When a value is named, that name cannot be used again within the same  scope . Names ( identifiers ) cannot start with a number, but a number can be included within the name.  1\n2\n3 \uc774\ub984   :=   \ub9cc\uc138  \ud83d\udd12    :=   true  \u03c4     :=   6.28", 
            "title": "Naming"
        }, 
        {
            "location": "/#scope-and-shadowing", 
            "text": "Blocks of code are organised as scopes. A scope is defined as the code in-between  {  and  } . You are entering a scope when you see  {  and exiting when you see  } . Variables and constants are allowed to enter a scope, but they are not allowed to leave the scope they are declared in.  For example:  1\n2\n3\n4\n5 message   :=   Hello!  { \n     print ( message )   // Prints  Hello!  }    is allowed because  message  is going deeper in scope. But:  1\n2\n3\n4\n5 { \n     message   :=   Hello!  }  print ( message )   // Error  Unknown identifier `message`    is not allowed because  message  is not allowed to exit the scope it was declared in. When entering a new scope, you are allowed to reuse names. This feature is known as  shadowing .  1\n2\n3\n4\n5\n6\n7 aValue   :=   8675309  { \n     aValue   :=   I shadowed a value. \n     print ( aValue )   // Prints  I shadowed a value.  }  print ( aValue )   // Prints  8675309", 
            "title": "Scope and Shadowing"
        }, 
        {
            "location": "/types/basic/", 
            "text": "Basic Types\n\n\nIntegers\n\n\n1\nx\n:\n \nint\n \n=\n \n5\n\n\n\n\n\n\n\n1\n2\nx\n:\n \nint\n \n5\n\n\ny\n:\n \ni64\n \n=\n \nx\n\n\n\n\n\n\n\n1\nz\n:\n \ni8\n \n=\n \n0\n\n\n\n\n\n\n\nReals\n\n\n1\n2\npi\n:\n \nfloat\n \n=\n \n3.14\n\n\ntau\n:\n \nf64\n \n=\n \n6.28\n\n\n\n\n\n\n\nBoolean\n\n\n1\n2\nhasValue\n \n:=\n \ntrue\n\n\ndoesNotHaveValue\n \n:=\n \nfalse\n\n\n\n\n\n\n\nStrings\n\n\n1\nname\n:\n \nstring\n \n=\n \nJohn\n\n\n\n\n\n\n\nUnconstrained Types\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nmyproc\n \n::\n \n(\nanI32\n:\n \ni32\n)\n \n-\n \nvoid\n \n{\n\n    \n// ...\n\n\n}\n\n\n\n// could be any integer type and will default to i64 if not constrained.\n\n\nunconstValue\n \n:=\n \n5\n\n\n\n\n\n// calling this procedure constrains the value to type i32.\n\n\nmyproc\n(\nanI32\n:\n \nunconstValue\n)", 
            "title": "Basic Types"
        }, 
        {
            "location": "/types/basic/#basic-types", 
            "text": "", 
            "title": "Basic Types"
        }, 
        {
            "location": "/types/basic/#integers", 
            "text": "1 x :   int   =   5    1\n2 x :   int   5  y :   i64   =   x    1 z :   i8   =   0", 
            "title": "Integers"
        }, 
        {
            "location": "/types/basic/#reals", 
            "text": "1\n2 pi :   float   =   3.14  tau :   f64   =   6.28", 
            "title": "Reals"
        }, 
        {
            "location": "/types/basic/#boolean", 
            "text": "1\n2 hasValue   :=   true  doesNotHaveValue   :=   false", 
            "title": "Boolean"
        }, 
        {
            "location": "/types/basic/#strings", 
            "text": "1 name :   string   =   John", 
            "title": "Strings"
        }, 
        {
            "location": "/types/basic/#unconstrained-types", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 myproc   ::   ( anI32 :   i32 )   -   void   { \n     // ...  }  // could be any integer type and will default to i64 if not constrained.  unconstValue   :=   5   // calling this procedure constrains the value to type i32.  myproc ( anI32 :   unconstValue )", 
            "title": "Unconstrained Types"
        }, 
        {
            "location": "/types/array/", 
            "text": "Arrays\n\n\n1\n2\nnames\n \n:=\n \n[\n3\n]\nstring\n \n{\n \nTim\n,\n \nS\u00f8ren\n,\n \nJane\n \n}\n\n\nnamesCopy\n \n:=\n \nnames\n\n\n\n\n\n\n\n1\n2\nprint\n(\nnames\n.\nlength\n)\n \n// 3\n\n\nprint\n(\nnames\n[\n0\n])\n \n// \nTim\n\n\n\n\n\n\n\nDynamic Arrays\n\n\n1\n2\n3\nnames\n \n:=\n \n[]\nstring\n\n\nnames\n \n=\n \nappend\n(\nnames\n,\n \nJames\n)\n\n\nprint\n(\nnames\n[\n0\n])\n \n// \nJames", 
            "title": "Arrays"
        }, 
        {
            "location": "/types/array/#arrays", 
            "text": "1\n2 names   :=   [ 3 ] string   {   Tim ,   S\u00f8ren ,   Jane   }  namesCopy   :=   names    1\n2 print ( names . length )   // 3  print ( names [ 0 ])   //  Tim", 
            "title": "Arrays"
        }, 
        {
            "location": "/types/array/#dynamic-arrays", 
            "text": "1\n2\n3 names   :=   [] string  names   =   append ( names ,   James )  print ( names [ 0 ])   //  James", 
            "title": "Dynamic Arrays"
        }, 
        {
            "location": "/types/pointer/", 
            "text": "", 
            "title": "Pointers"
        }, 
        {
            "location": "/types/enumeration/", 
            "text": "Declaration\n\n\n1\n2\n3\n4\n5\n6\nDirection\n \n::\n \nenum\n \n{\n\n    \nup\n,\n\n    \ndown\n,\n\n    \nleft\n,\n\n    \nright\n\n\n}\n\n\n\n\n\n\n\nVariable Declaration\n\n\n1\ndirection\n \n:=\n \nDirection\n.\nup\n\n\n\n\n\n\n\nControl Flow\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\ndirection\n \n:=\n \nDirection\n.\ndown\n\n\n\nswitch\n \ndirection\n \n{\n\n\ncase\n \nDirection\n.\nup\n\n    \nprint\n(\nup\n)\n\n\n\ncase\n \nDirection\n.\ndown\n\n    \nprint\n(\ndown\n)\n\n\n\ncase\n \nDirection\n.\nleft\n\n    \nprint\n(\nleft\n)\n\n\n\ncase\n \nDirection\n.\nright\n\n    \nprint\n(\nright\n)\n\n\n}\n\n\n\n\n\n\n\n\n\nNote\n\n\nLearn more about \nControl Flow\n \nhere\n.\n\n\n\n\nAssociated values\n\n\n1\n2\n3\n4\n5\nMode\n \n::\n \nenum\n(\nu8\n)\n \n{\n\n    \nindirect\n \n=\n \n1\n,\n\n    \nrelative\n,\n\n    \nabsolute\n\n\n}", 
            "title": "Enums"
        }, 
        {
            "location": "/types/enumeration/#declaration", 
            "text": "1\n2\n3\n4\n5\n6 Direction   ::   enum   { \n     up , \n     down , \n     left , \n     right  }", 
            "title": "Declaration"
        }, 
        {
            "location": "/types/enumeration/#variable-declaration", 
            "text": "1 direction   :=   Direction . up", 
            "title": "Variable Declaration"
        }, 
        {
            "location": "/types/enumeration/#control-flow", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 direction   :=   Direction . down  switch   direction   {  case   Direction . up \n     print ( up )  case   Direction . down \n     print ( down )  case   Direction . left \n     print ( left )  case   Direction . right \n     print ( right )  }     Note  Learn more about  Control Flow   here .", 
            "title": "Control Flow"
        }, 
        {
            "location": "/types/enumeration/#associated-values", 
            "text": "1\n2\n3\n4\n5 Mode   ::   enum ( u8 )   { \n     indirect   =   1 , \n     relative , \n     absolute  }", 
            "title": "Associated values"
        }, 
        {
            "location": "/types/union/", 
            "text": "Declaration\n\n\n1\n2\n3\n4\n5\nData\n \n::\n \nunion\n \n{\n\n    \ni\n:\n \ni64\n,\n\n    \nf\n:\n \nf64\n,\n\n    \ns\n:\n \nstring\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\ndata\n \n:=\n \nData\n\n\ndata\n.\nf\n \n=\n \n3.14159\n\n\nprintf\n(\ndata.f: %f\n\\n\n.\nraw\n,\n \ndata\n.\nf\n)\n\n\nprintf\n(\ndata.i: %d\n\\n\n.\nraw\n,\n \ndata\n.\ni\n)\n\n\nprintf\n(\ndata.s: %s\n\\n\n.\nraw\n,\n \ndata\n.\ns\n)\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\ndata\n \n:=\n \nData\n\n\n\ndata\n.\ni\n \n=\n \n100\n\n\nprintf\n(\ndata.i: %d\n\\n\n.\nraw\n,\n \ndata\n.\ni\n)\n\n\n\ndata\n.\nf\n \n=\n \n3.14159\n\n\nprintf\n(\ndata.f: %f\n\\n\n.\nraw\n,\n \ndata\n.\nf\n)\n\n\n\ndata\n.\ns\n \n=\n \nUnions!\n\n\nprintf\n(\ndata.s: %s\n\\n\n.\nraw\n,\n \ndata\n.\ns\n)", 
            "title": "Unions"
        }, 
        {
            "location": "/types/union/#declaration", 
            "text": "1\n2\n3\n4\n5 Data   ::   union   { \n     i :   i64 , \n     f :   f64 , \n     s :   string  }    1\n2\n3\n4\n5 data   :=   Data  data . f   =   3.14159  printf ( data.f: %f \\n . raw ,   data . f )  printf ( data.i: %d \\n . raw ,   data . i )  printf ( data.s: %s \\n . raw ,   data . s )     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 data   :=   Data  data . i   =   100  printf ( data.i: %d \\n . raw ,   data . i )  data . f   =   3.14159  printf ( data.f: %f \\n . raw ,   data . f )  data . s   =   Unions!  printf ( data.s: %s \\n . raw ,   data . s )", 
            "title": "Declaration"
        }, 
        {
            "location": "/types/struct/", 
            "text": "Structs\n\n\nDeclaration\n\n\n1\n2\n3\n4\nPerson\n \n::\n \nstruct\n \n{\n\n    \nname\n:\n \nstring\n\n    \nage\n:\n \nu8\n\n\n}\n\n\n\n\n\n\n\nInitialization\n\n\n1\n2\n3\n4\nme\n \n:=\n \nPerson\n \n{\n\n    \nGlenn\n,\n\n    \n30\n\n\n}\n\n\n\n\n\n\n\nStruct initialization can be with or without argument labels. If the labels are provided, the fields can be declared in any order. For example:\n\n\n1\n2\n3\n4\nme\n \n:=\n \nPerson\n \n{\n\n    \nage\n:\n \n24\n,\n\n    \nname\n:\n \nBrett\n\n\n}", 
            "title": "Structs"
        }, 
        {
            "location": "/types/struct/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/types/struct/#declaration", 
            "text": "1\n2\n3\n4 Person   ::   struct   { \n     name :   string \n     age :   u8  }", 
            "title": "Declaration"
        }, 
        {
            "location": "/types/struct/#initialization", 
            "text": "1\n2\n3\n4 me   :=   Person   { \n     Glenn , \n     30  }    Struct initialization can be with or without argument labels. If the labels are provided, the fields can be declared in any order. For example:  1\n2\n3\n4 me   :=   Person   { \n     age :   24 , \n     name :   Brett  }", 
            "title": "Initialization"
        }, 
        {
            "location": "/types/type-def/", 
            "text": "1\n2\nInt64\n \n::\n \ni64\n\n\nLong\n \n::\n \nInt64\n\n\n\n\n\n\n\n1\nInt\n \n::\n \n#\nforeign\n(\nLLVM\n)\n \ni64", 
            "title": "Type Definition"
        }, 
        {
            "location": "/operator/", 
            "text": "", 
            "title": "Operators"
        }, 
        {
            "location": "/control-flow/", 
            "text": "If Statement\n\n\n1\n2\n3\nif\n \ntrue\n \n==\n \n1\n \n{\n\n    \n// ...\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\nif\n \nfalse\n \n{\n\n    \n// won\nt be executed\n\n\n}\n \nelse\n \n{\n\n    \n// ...\n\n\n}\n\n\n\n\n\n\n\nFor Loop\n\n\n1\n2\n3\nfor\n \ni\n=\n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n \n{\n\n    \n// ... runs 10 times\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\nfor\n \nchild\n \nin\n \nchildren\n \n{\n\n    \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n\nNote\n\n\nLearn more about \nArrays\n \nhere\n.\n\n\n\n\nWhile Loop\n\n\n1\n2\n3\nfor\n \ntrue\n \n{\n\n    \n// ...\n\n\n}\n\n\n\n\n\n\n\nSwitch Statement\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nswitch\n \ngender\n \n{\n\n    \ncase\n \n.\nmale\n:\n\n        \nbreak\n\n\n    \ncase\n \n.\nfemale\n:\n\n        \nbreak\n\n\n    \ncase\n:\n \n// default\n\n        \nbreak\n\n\n}\n\n\n\n\n\n\n\n\n\nNote\n\n\nLearn more about \nEnumerations\n \nhere\n.\n\n\n\n\nReturn Statement\n\n\n1\nreturn\n \n0", 
            "title": "Control Flow"
        }, 
        {
            "location": "/control-flow/#if-statement", 
            "text": "1\n2\n3 if   true   ==   1   { \n     // ...  }    1\n2\n3\n4\n5 if   false   { \n     // won t be executed  }   else   { \n     // ...  }", 
            "title": "If Statement"
        }, 
        {
            "location": "/control-flow/#for-loop", 
            "text": "1\n2\n3 for   i = 0 ;   i     10 ;   i ++   { \n     // ... runs 10 times  }    1\n2\n3 for   child   in   children   { \n     // ...  }     Note  Learn more about  Arrays   here .", 
            "title": "For Loop"
        }, 
        {
            "location": "/control-flow/#while-loop", 
            "text": "1\n2\n3 for   true   { \n     // ...  }", 
            "title": "While Loop"
        }, 
        {
            "location": "/control-flow/#switch-statement", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 switch   gender   { \n     case   . male : \n         break \n\n     case   . female : \n         break \n\n     case :   // default \n         break  }     Note  Learn more about  Enumerations   here .", 
            "title": "Switch Statement"
        }, 
        {
            "location": "/control-flow/#return-statement", 
            "text": "1 return   0", 
            "title": "Return Statement"
        }, 
        {
            "location": "/procedure/", 
            "text": "1\n2\n3\nsum\n \n::\n \n(\na\n:\n \ni32\n,\n \nb\n:\n \ni32\n)\n \n-\n \ni32\n \n{\n\n    \nreturn\n \na\n \n+\n \nb\n\n\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\nJust like variable declarations, multiple parameters of the same type can be declared as a list followed by their type. Example: \nmul :: (a, b: i32) -\n i32\n\n\n\n\nKai also supports multiple returns.\n\n\n1\n2\n3\n4\n5\n6\nsumAndMul\n \n::\n \n(\na\n,\n \nb\n:\n \ni32\n)\n \n-\n \ni32\n,\n \ni32\n \n{\n\n    \nsum\n \n:=\n \na\n \n+\n \nb\n\n    \nprod\n \n:=\n \na\n \n*\n \nb\n\n\n    \nreturn\n \nsum\n,\n \nprod\n\n\n}", 
            "title": "Procedures"
        }, 
        {
            "location": "/module/", 
            "text": "Import a File\n\n\n1\n#\nimport\n \nstrings.kai\n\n\n\n\n\n\n\nImport from Git\n\n\n1\n2\n3\n4\n5\n// github\n\n\n#\nimport\n \ngit\n(\nauthor/repo\n)\n\n\n\n// external\n\n\n#\nimport\n \ngit\n(\nhttps://external.com/author/repo\n)\n\n\n\n\n\n\n\nAlias an Import\n\n\n1\n2\n#\nimport\n \nmath\n \nmathy\n\n\nprint\n(\nmathy\n.\npi\n)\n\n\n\n\n\n\n\nImport a C Header\n\n\n1\n#\nimport\n \nstdio.h\n\n\n\n\n\n\n\n\n\nNote\n\n\nLearn more about \nWorking with C\n \nhere\n.\n\n\n\n\nPre-Compiled Library\n\n\n1\n2\n// include and link against glibc\n\n\n#\nlibrary\n \n/path/to/umbrella.h\n \nglibc", 
            "title": "Import and Modules"
        }, 
        {
            "location": "/module/#import-a-file", 
            "text": "1 # import   strings.kai", 
            "title": "Import a File"
        }, 
        {
            "location": "/module/#import-from-git", 
            "text": "1\n2\n3\n4\n5 // github  # import   git ( author/repo )  // external  # import   git ( https://external.com/author/repo )", 
            "title": "Import from Git"
        }, 
        {
            "location": "/module/#alias-an-import", 
            "text": "1\n2 # import   math   mathy  print ( mathy . pi )", 
            "title": "Alias an Import"
        }, 
        {
            "location": "/module/#import-a-c-header", 
            "text": "1 # import   stdio.h     Note  Learn more about  Working with C   here .", 
            "title": "Import a C Header"
        }, 
        {
            "location": "/module/#pre-compiled-library", 
            "text": "1\n2 // include and link against glibc  # library   /path/to/umbrella.h   glibc", 
            "title": "Pre-Compiled Library"
        }, 
        {
            "location": "/compile-time/", 
            "text": "", 
            "title": "Compile Time Execution"
        }, 
        {
            "location": "/entry-point/", 
            "text": "The application entry point\n\n\n1\n2\n3\nmain\n \n::\n \n()\n \n-\n \nvoid\n \n{\n\n    \nprint\n(\nHello, world!\n)\n\n\n}", 
            "title": "Entry Point"
        }, 
        {
            "location": "/entry-point/#the-application-entry-point", 
            "text": "1\n2\n3 main   ::   ()   -   void   { \n     print ( Hello, world! )  }", 
            "title": "The application entry point"
        }, 
        {
            "location": "/c/", 
            "text": "", 
            "title": "Working with C"
        }
    ]
}